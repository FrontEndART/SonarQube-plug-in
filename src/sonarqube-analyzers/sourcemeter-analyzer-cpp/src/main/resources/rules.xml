<?xml version="1.0" encoding="UTF-8"?>
<rulset xmlns = "http://pmd.sourceforge.net/ruleset/2.0.0" xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation = "http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
  <rule key = "MET_AD">
    <name>API Documentation (AD) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; ratio of the number of documented public methods in the class +1 if the class itself is documented to the number of all public methods in the class + 1 (the class itself); however, the nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Enum:&lt;/strong&gt; ratio of the number of documented enumerators in the enum +1 if the enum itself is documented to the number of all enumerators in the enum + 1 (the enum itself).&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; ratio of the number of documented public classes and methods in the namespace to the number of all of its public classes and methods; however, the classes and methods of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CBO">
    <name>Coupling Between Object classes (CBO) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of directly used other classes (e.g. by inheritance, function call, type reference, attribute reference). Classes using many other classes highly depend on their environment, so it is difficult to test or reuse them; furthermore, they are very sensitive to the changes in the system.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CBOI">
    <name>Coupling Between Object classes Inverse (CBOI) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of other classes, which directly use the class. Classes which are used by many other classes have a high impact on the behavior of the system, and should be modified very carefully and tested intensively.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CD">
    <name>Comment Density (CD) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; ratio of the comment lines of the method (CLOC) to the sum of its comment (CLOC) and logical lines of code (LLOC).&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union:&lt;/strong&gt; ratio of the comment lines of the class (CLOC) to the sum of its comment (CLOC) and logical lines of code (LLOC).&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; ratio of the comment lines of the namespace (CLOC) to the sum of its comment (CLOC) and logical lines of code (LLOC).&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CLOC">
    <name>Comment Lines of Code (CLOC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of comment and documentation code lines of the method; however, its anonymous and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of comment and documentation code lines of the class, including its local methods and attributes; however, its nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of comment and documentation code lines of the namespace; however, its subnamespaces are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;File:&lt;/strong&gt; number of comment and documentation code lines of the file.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_DIT">
    <name>Depth of Inheritance Tree (DIT) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; length of the path that leads from the class to its farthest ancestor in the inheritance tree.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_DLOC">
    <name>Documentation Lines of Code (DLOC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of documentation code lines of the method.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of documentation code lines of the class, including its local methods and attributes; however, its nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Enum:&lt;/strong&gt; number of documentation code lines of the enum, including its enumerators.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_HCPL">
    <name>Halstead Calculated Program Length (HCPL) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt;&lt;/p&gt;&#x0A;&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;n1&lt;/em&gt;: number of distinct operators (semantic meanings of the reserved keywords, semicolons, blocks, and identifiers except in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n2&lt;/em&gt;: number of distinct operands (literals - e.g. character, string, and integer literals, - and the identifiers in their declarations)&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;The calculated program length is &lt;em&gt;n1 * log&lt;sub&gt;2&lt;/sub&gt;(n1) + n2 * log&lt;sub&gt;2&lt;/sub&gt;(n2)&lt;/em&gt;.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_HDIF">
    <name>Halstead Difficulty (HDIF) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt;&lt;/p&gt;&#x0A;&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;n1&lt;/em&gt;: number of distinct operators (semantic meanings of the reserved keywords, semicolons, blocks, and identifiers except in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n2&lt;/em&gt;: number of distinct operands (literals - e.g. character, string, and integer literals, - and the identifiers in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N2&lt;/em&gt;: total number of operands&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;The Halstead difficulty is &lt;em&gt;n1/2 * N2/n2&lt;/em&gt;.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_HEFF">
    <name>Halstead Effort (HEFF) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt;&lt;/p&gt;&#x0A;&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;n1&lt;/em&gt;: number of distinct operators (semantic meanings of the reserved keywords, semicolons, blocks, and identifiers except in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n2&lt;/em&gt;: number of distinct operands (literals - e.g. character, string, and integer literals, - and the identifiers in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N1&lt;/em&gt;: total number of operators&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N2&lt;/em&gt;: total number of operands&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n : n1 + n2&lt;/em&gt; (program vocabulary)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N : N1 + N2&lt;/em&gt; (program length)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;V : N * log&lt;sub&gt;2&lt;/sub&gt;(n)&lt;/em&gt; (volume)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;D : n1/2 * N2/n2&lt;/em&gt; (difficulty)&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;The Halstead effort is &lt;em&gt;D * V&lt;/em&gt;.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_HNDB">
    <name>Halstead Number of Delivered Bugs (HNDB) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt;&lt;/p&gt;&#x0A;&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;n1&lt;/em&gt;: number of distinct operators (semantic meanings of the reserved keywords, semicolons, blocks, and identifiers except in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n2&lt;/em&gt;: number of distinct operands (literals - e.g. character, string, and integer literals, - and the identifiers in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N1&lt;/em&gt;: total number of operators&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N2&lt;/em&gt;: total number of operands&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n : n1 + n2&lt;/em&gt; (program vocabulary)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N : N1 + N2&lt;/em&gt; (program length)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;V : N * log&lt;sub&gt;2&lt;/sub&gt;(n)&lt;/em&gt; (volume)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;D : n1/2 * N2/n2&lt;/em&gt; (difficulty)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;E : D * V&lt;/em&gt; (effort)&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;Number of delivered bugs is &lt;em&gt;E&lt;sup&gt;2/3&lt;/sup&gt;/3000&lt;/em&gt;.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_HPL">
    <name>Halstead Program Length (HPL) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt;&lt;/p&gt;&#x0A;&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;N1&lt;/em&gt;: total number of operators (semantic meanings of the reserved keywords, semicolons, blocks, and identifiers except in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N2&lt;/em&gt;: total number of operands (literals - e.g. character, string, and integer literals, - and the identifiers in their declarations)&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;Halstead program length is &lt;em&gt;N1 + N2&lt;/em&gt;.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_HPV">
    <name>Halstead Program Vocabulary (HPV) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt;&lt;/p&gt;&#x0A;&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;n1&lt;/em&gt;: number of distinct operators (semantic meanings of the reserved keywords, semicolons, blocks, and identifiers except in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n2&lt;/em&gt;: number of distinct operands (literals - e.g. character, string, and integer literals, - and the identifiers in their declarations)&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;Halstead program vocabulary is &lt;em&gt;n1 + n2&lt;/em&gt;.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_HTRP">
    <name>Halstead Time Required to Program (HTRP) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt;&lt;/p&gt;&#x0A;&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;n1&lt;/em&gt;: number of distinct operators (semantic meanings of the reserved keywords, semicolons, blocks, and identifiers except in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n2&lt;/em&gt;: number of distinct operands (literals - e.g. character, string, and integer literals, - and the identifiers in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N1&lt;/em&gt;: total number of operators&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N2&lt;/em&gt;: total number of operands&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n : n1 + n2&lt;/em&gt; (program vocabulary)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N : N1 + N2&lt;/em&gt; (program length)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;V : N * log&lt;sub&gt;2&lt;/sub&gt;(n)&lt;/em&gt; (volume)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;D : n1/2 * N2/n2&lt;/em&gt; (difficulty)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;E : D * V&lt;/em&gt; (effort)&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;Halstead time required to program is &lt;em&gt;E/18&lt;/em&gt; seconds.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_HVOL">
    <name>Halstead Volume (HVOL) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt;&lt;/p&gt;&#x0A;&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;n1&lt;/em&gt;: number of distinct operators (semantic meanings of the reserved keywords, semicolons, blocks, and identifiers except in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n2&lt;/em&gt;: number of distinct operands (literals - e.g. character, string, and integer literals, - and the identifiers in their declarations)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N1&lt;/em&gt;: total number of operators&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N2&lt;/em&gt;: total number of operands&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;n : n1 + n2&lt;/em&gt; (program vocabulary)&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;N : N1 + N2&lt;/em&gt; (program length)&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;The Halstead volume is &lt;em&gt;N * log&lt;sub&gt;2&lt;/sub&gt;(n)&lt;/em&gt;.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_LCOM5">
    <name>Lack of Cohesion in Methods 5 (LCOM5) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union:&lt;/strong&gt; number of functionalities of the class. One of the basic principles of object-oriented programming is encapsulation, meaning that attributes belonging together and the operations that use them should be organized into one class, and one class shall implement only one functionality, i.e. its attributes and methods should be coherent. This metric measures the lack of cohesion and computes into how many coherent classes the class could be split. It is calculated by taking a non-directed graph, where the nodes are the implemented local methods of the class and there is an edge between the two nodes if and only if a common (local or inherited) attribute or abstract method is used or a method invokes another. The value of the metric is the number of connected components in the graph not counting those, which contain only constructors, destructors, getters, or setters.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_LLOC">
    <name>Logical Lines of Code (LLOC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of non-empty and non-comment code lines of the method; however, its anonymous and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of non-empty and non-comment code lines of the class, including the non-empty and non-comment lines of its local methods; however, its nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Enum:&lt;/strong&gt; number of non-empty and non-comment code lines of the enum.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of non-empty and non-comment code lines of the namespace; however, its subnamespaces are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;File:&lt;/strong&gt; number of non-empty and non-comment code lines of the file.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_LOC">
    <name>Lines of Code (LOC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of code lines of the method, including empty and comment lines; however, its anonymous and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of code lines of the class, including empty and comment lines, as well as its local methods; however, its nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Enum:&lt;/strong&gt; number of code lines of the enum, including empty and comment lines.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of code lines of the namespace, including empty and comment lines; however, its subnamespaces are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;File:&lt;/strong&gt; number of code lines of the file, including empty and comment lines.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_MI">
    <name>Maintainability Index (Original version) (MI) Metric Threshold Violation</name>
    <description>&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;HVOL&lt;/em&gt;: Halstead Volume&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;McCC&lt;/em&gt;: McCabe’s cyclomatic complexity&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;LLOC&lt;/em&gt;: logical lines of code&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;The original Maintainability Index is computed by the following formula:&lt;/p&gt;&#x0A;&lt;p&gt;&lt;em&gt;MI = 171 - 5.2 * ln(HVOL) - 0.23 * (McCC) - 16.2 * ln(LLOC)&lt;/em&gt;&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_MIMS">
    <name>Maintainability Index (Microsoft version) (MIMS) Metric Threshold Violation</name>
    <description>&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;HVOL&lt;/em&gt;: Halstead Volume&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;McCC&lt;/em&gt;: McCabe’s cyclomatic complexity&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;LLOC&lt;/em&gt;: logical lines of code&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;The Maintainability Index used by Microsoft’s Visual Studio is computed by the following formula:&lt;/p&gt;&#x0A;&lt;p&gt;&lt;em&gt;MIMS = max(0,(171 - 5.2 * ln(HVOL) - 0.23 * (McCC) - 16.2 * ln(LLOC)) * 100 / 171)&lt;/em&gt;&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_MISEI">
    <name>Maintainability Index (SEI version) (MISEI) Metric Threshold Violation</name>
    <description>&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;HVOL&lt;/em&gt;: Halstead Volume&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;McCC&lt;/em&gt;: McCabe’s cyclomatic complexity&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;LLOC&lt;/em&gt;: logical lines of code&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;CD&lt;/em&gt;: comment density&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;The Maintainability Index derived by the Software Engineering Institute (SEI) is computed by the following formula:&lt;/p&gt;&#x0A;&lt;p&gt;&lt;em&gt;MISEI = 171 - 5.2 * log&lt;sub&gt;2&lt;/sub&gt;(HVOL) - 0.23 * McCC - 16.2 * log&lt;sub&gt;2&lt;/sub&gt;(LLOC) + 50 * sin(sqrt(2.4 * CD))&lt;/em&gt;&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_MISM">
    <name>Maintainability Index (SourceMeter version) (MISM) Metric Threshold Violation</name>
    <description>&lt;ul&gt;&#x0A;&lt;li&gt;&lt;em&gt;HVOL&lt;/em&gt;: Halstead Volume&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;McCC&lt;/em&gt;: McCabe’s cyclomatic complexity&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;LLOC&lt;/em&gt;: logical lines of code&lt;/li&gt;&#x0A;&lt;li&gt;&lt;em&gt;CD&lt;/em&gt;: comment density&lt;/li&gt;&#x0A;&lt;/ul&gt;&#x0A;&lt;p&gt;The Maintainability Index proposed by SourceMeter combines the different scaling approach from Microsoft’s version with the inclusion of comment percentage from the Software Engineering Institute (SEI) version into the following formula:&lt;/p&gt;&#x0A;&lt;p&gt;&lt;em&gt;MISM = max(0, (171 - 5.2 * log&lt;sub&gt;2&lt;/sub&gt;(HVOL) - 0.23 * McCC - 16.2 * log&lt;sub&gt;2&lt;/sub&gt;(LLOC) + 50 * sin(sqrt(2.4 * CD))) * 100 / 171)&lt;/em&gt;&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_McCC">
    <name>McCabe&apos;s Cyclomatic Complexity (McCC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; complexity of the method expressed as the number of independent control flow paths in it. It represents a lower bound for the number of possible execution paths in the source code and at the same time it is an upper bound for the minimum number of test cases needed for achieving full branch test coverage. The value of the metric is calculated as the number of the following instructions plus 1: if, for, foreach, range-based for, while, do-while, case label (which belongs to a switch instruction), catch, conditional expression (?:). Moreover, logical “and” (&amp;amp;&amp;amp;) and logical “or” (||) expressions also add 1 to the value because their short-circuit evaluation can cause branching depending on the first operand. The following instructions are not included: else, switch, default label (which belongs to a switch instruction), try.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;File:&lt;/strong&gt; complexity of the file expressed as the number of independent control flow paths in it. It represents a lower bound for the number of possible execution paths in the source code and at the same time it is an upper bound for the minimum number of test cases needed for achieving full branch test coverage. The value of the metric is calculated as the number of the following instructions plus 1: if, for, foreach, range-based for, while, do-while, case label (which belongs to a switch instruction), catch, conditional expression (?:). Moreover, logical “and” (&amp;amp;&amp;amp;) and logical “or” (||) expressions also add 1 to the value because their short-circuit evaluation can cause branching depending on the first operand. The following instructions are not included: else, switch, default label (which belongs to a switch instruction), try.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NA">
    <name>Number of Attributes (NA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of attributes in the class, including the inherited ones; however, the attributes of its nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Enum:&lt;/strong&gt; number of enumerators in the enum.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of attributes in the namespace; however, attributes of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NCL">
    <name>Number of Classes (NCL) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of classes in the namespace; however, the classes of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NEN">
    <name>Number of Enums (NEN) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of enums in the namespace; however, the enums of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NG">
    <name>Number of Getters (NG) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of getter methods in the class, including the inherited ones; however, the getter methods of its nested, anonymous, and local classes are not included. Methods that override abstract methods are not counted.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of getter methods in the namespace; however, getter methods of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NII">
    <name>Number of Incoming Invocations (NII) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of other methods and attribute initializations which directly call the method. If the method is invoked several times from the same method or attribute initialization, it is counted only once.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of other methods and attribute initializations which directly call the local methods of the class. If a method is invoked several times from the same method or attribute initialization, it is counted only once.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NIN">
    <name>Number of Interfaces (NIN) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of interfaces in the namespace; however, the interfaces of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NL">
    <name>Nesting Level (NL) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; complexity of the method expressed as the depth of the maximum embeddedness of its conditional, iteration and exception handling block scopes. The following instructions are taken into account: if, else-if, else, for, while, do-while, switch, try, catch and block statements that are directly inside another block statement. The following instructions do not increase the value by themselves; however, if additional embeddednesses can be found in their blocks, they are considered: case and default label (which belong to a switch instruction).&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union:&lt;/strong&gt; complexity of the class expressed as the depth of the maximum embeddedness of its conditional, iteration and exception handling block scopes. It is calculated as the maximum nesting level (NL) of its local methods.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NLA">
    <name>Number of Local Attributes (NLA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) attributes in the class; however, the attributes of nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NLE">
    <name>Nesting Level Else-If (NLE) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; complexity of the method expressed as the depth of the maximum embeddedness of its conditional, iteration and exception handling block scopes, where in the if-else-if construct only the first if instruction is considered. The following instructions are taken into account: if, else, for, while, do-while, switch, try, catch and block statements that are directly inside another block statement. The following instructions do not increase the value by themselves; however, if additional embeddednesses can be found in their blocks, they are considered: else-if (i.e. in the if-else-if construct the use of else-if does not increase the value of the metric), case and default label (which belong to a switch instruction).&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union:&lt;/strong&gt; complexity of the class expressed as the depth of the maximum embeddedness of its conditional, iteration and exception handling block scopes, where in the if-else-if construct only the first if instruction is considered. It is calculated as the maximum nesting level (NLE) of its local methods.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NLG">
    <name>Number of Local Getters (NLG) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) getter methods in the class; however, the getter methods of its nested, anonymous, and local classes are not included. Methods that override abstract methods are not counted.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NLM">
    <name>Number of Local Methods (NLM) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) methods in the class; however, the methods of nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NLPA">
    <name>Number of Local Public Attributes (NLPA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) public attributes in the class; however, the attributes of nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NLPM">
    <name>Number of Local Public Methods (NLPM) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) public methods in the class; however, the methods of nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NLS">
    <name>Number of Local Setters (NLS) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) setter methods in the class; however, the setter methods of its nested, anonymous, and local classes are not included. Methods that override abstract methods are not counted.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NM">
    <name>Number of Methods (NM) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of methods in the class, including the inherited ones; however, the methods of its nested, anonymous and local classes are not included. Methods that override abstract methods are not counted.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of methods in the namespace; however, methods of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NOA">
    <name>Number of Ancestors (NOA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of classes, interfaces, enums and annotations from which the class is directly or indirectly inherited.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NOC">
    <name>Number of Children (NOC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of classes, interfaces, enums and annotations which are directly derived from the class.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NOD">
    <name>Number of Descendants (NOD) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of classes, interfaces, enums, annotations, which are directly or indirectly derived from the class.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NOI">
    <name>Number of Outgoing Invocations (NOI) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of directly called methods. If a method is invoked several times, it is counted only once.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union:&lt;/strong&gt; number of directly called methods of other classes, including method invocations from attribute initializations. If a method is invoked several times, it is counted only once.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NOP">
    <name>Number of Parents (NOP) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of classes, interfaces, enums and annotations from which the class is directly inherited.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NOS">
    <name>Number of Statements (NOS) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of statements in the method; however, the statements of its anonymous and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union:&lt;/strong&gt; number of statements in the class; however, the statements of its nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;File:&lt;/strong&gt; number of statements in the file.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NPA">
    <name>Number of Public Attributes (NPA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of public attributes in the class, including the inherited ones; however, the public attributes of its nested, anonymous, and local classes are not included.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of public attributes in the namespace; however, the public attributes of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NPKG">
    <name>Number of Packages (NPKG) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of directly contained subnamespaces of the namespace.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NPM">
    <name>Number of Public Methods (NPM) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of public methods in the class, including the inherited ones; however, the public methods of nested, anonymous, and local classes are not included. Methods that override abstract methods are not counted.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of public methods in the namespace; however, the public methods of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NS">
    <name>Number of Setters (NS) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of setter methods in the class, including the inherited ones; however, the setter methods of its nested, anonymous, and local classes are not included. Methods that override abstract methods are not counted.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of setter methods in the namespace; however, setter methods of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NST">
    <name>Number of Structures (NST) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of structures in the namespace; however, the structures of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NUMPAR">
    <name>Number of Parameters (NUMPAR) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of the parameters of the method. The varargs parameter counts as one.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_NUN">
    <name>Number of Unions (NUN) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of unions in the namespace; however, the unions of its subnamespaces are not included.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_PDA">
    <name>Public Documented API (PDA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of documented public methods in the class (+1 if the class itself is documented); however, the methods of its nested, anonymous, and local classes are not counted.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of documented public classes and methods in the namespace; however, the classes and methods of its subnamespaces are not counted.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;File:&lt;/strong&gt; number of documented public classes and methods in the file.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_PUA">
    <name>Public Undocumented API (PUA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of undocumented public methods in the class (+1 if the class itself is undocumented); however, the methods of its nested, anonymous, and local classes are not counted.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of undocumented public classes and methods in the namespace; however, the classes and methods of its subnamespaces are not counted.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;File:&lt;/strong&gt; number of undocumented public classes and methods in the file.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_RFC">
    <name>Response set For Class (RFC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union:&lt;/strong&gt; number of local (i.e. not inherited) methods in the class (NLM) plus the number of directly invoked other methods by its methods or attribute initializations (NOI).&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TAD">
    <name>Total API Documentation (TAD) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; ratio of the number of documented public classes and methods in the namespace to the number of all of its public classes and methods, including its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; ratio of the number of documented public classes and methods in the component to the number of all of its public classes and methods, including its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TCD">
    <name>Total Comment Density (TCD) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; ratio of the total comment lines of the method (TCLOC) to the sum of its total comment (TCLOC) and total logical lines of code (TLLOC).&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union:&lt;/strong&gt; ratio of the total comment lines of the class (TCLOC) to the sum of its total comment (TCLOC) and total logical lines of code (TLLOC).&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; ratio of the total comment lines of the namespace (TCLOC) to the sum of its total comment (TCLOC) and total logical lines of code (TLLOC).&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; ratio of the total comment lines of the component (TCLOC) to the sum of its total comment (TCLOC) and total logical lines of code (TLLOC).&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TCLOC">
    <name>Total Comment Lines of Code (TCLOC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of comment and documentation code lines of the method, including its anonymous and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of comment and documentation code lines of the class, including its local methods and attributes, as well as its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of comment and documentation code lines of the namespace, including its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of comment and documentation code lines of the component, including its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TLLOC">
    <name>Total Logical Lines of Code (TLLOC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of non-empty and non-comment code lines of the method, including the non-empty and non-comment lines of its anonymous and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of non-empty and non-comment code lines of the class, including the non-empty and non-comment code lines of its local methods, anonymous, local, and nested classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of non-empty and non-comment code lines of the namespace, including its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of non-empty and non-comment code lines of the component, including its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TLOC">
    <name>Total Lines of Code (TLOC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of code lines of the method, including empty and comment lines, as well as its anonymous and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of code lines of the class, including empty and comment lines, as well as its local methods, anonymous, local, and nested classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of code lines of the namespace, including empty and comment lines, as well as its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of code lines of the component, including empty and comment lines, as well as its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNA">
    <name>Total Number of Attributes (TNA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of attributes in the class, including the inherited ones, as well as the inherited and local attributes of its nested, anonymous and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of attributes in the namespace, including the attributes of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of attributes in the component, including the attributes of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNCL">
    <name>Total Number of Classes (TNCL) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of classes in the namespace, including the classes of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of classes in the component, including the classes of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNDI">
    <name>Total Number of Directories (TNDI) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of directories that belong to the namespace, including the directories of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of directories that belong to the component, including its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNEN">
    <name>Total Number of Enums (TNEN) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of enums in the namespace, including the enums of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of enums in the component, including the enums of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNFI">
    <name>Total Number of Files (TNFI) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of files that belong to the namespace, including the files of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of files that belong to the component, including its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNG">
    <name>Total Number of Getters (TNG) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of getter methods in the class, including the inherited ones, as well as the inherited and local getter methods of its nested, anonymous and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of getter methods in the namespace, including the getter methods of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of getter methods in the component, including the getter methods of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNIN">
    <name>Total Number of Interfaces (TNIN) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of interfaces in the namespace, including the interfaces of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of interfaces in the component, including the interfaces of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNLA">
    <name>Total Number of Local Attributes (TNLA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) attributes in the class, including the attributes of its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNLG">
    <name>Total Number of Local Getters (TNLG) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) getter methods in the class, including the local getter methods of its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNLM">
    <name>Total Number of Local Methods (TNLM) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) methods in the class, including the local methods of its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNLPA">
    <name>Total Number of Local Public Attributes (TNLPA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) public attributes in the class, including the local public attributes of its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNLPM">
    <name>Total Number of Local Public Methods (TNLPM) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) public methods in the class, including the local methods of its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNLS">
    <name>Total Number of Local Setters (TNLS) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; number of local (i.e. not inherited) setter methods in the class, including the local setter methods of its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNM">
    <name>Total Number of Methods (TNM) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of methods in the class, including the inherited ones, as well as the inherited and local methods of its nested, anonymous, and local classes. Methods that override abstract methods are not counted.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of methods in the namespace, including the methods of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of methods in the component, including the methods of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNOS">
    <name>Total Number of Statements (TNOS) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Method, Function:&lt;/strong&gt; number of statements in the method, including the statements of its anonymous and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Class, Structure, Union:&lt;/strong&gt; number of statements in the class, including the statements of its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of statements in the namespace, including the statements of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of statements in the component, including the statements of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNPA">
    <name>Total Number of Public Attributes (TNPA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of public attributes in the class, including the inherited ones, as well as the inherited and local public attributes of its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of public attributes in the namespace, including the public attributes of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of public attributes in the component, including the public attributes of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNPCL">
    <name>Total Number of Public Classes (TNPCL) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of public classes in the namespace, including the public classes of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of public classes in the component, including the public classes of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNPEN">
    <name>Total Number of Public Enums (TNPEN) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of public enums in the namespace, including the public enums of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of public enums in the component, including the public enums of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNPIN">
    <name>Total Number of Public Interfaces (TNPIN) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of public interfaces in the namespace, including the public interfaces of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of public interfaces in the component, including the public interfaces of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNPKG">
    <name>Total Number of Packages (TNPKG) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of subnamespaces in the namespace, including all directly or indirectly contained subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of namespaces and subnamespaces that belong to the component, including its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNPM">
    <name>Total Number of Public Methods (TNPM) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of public methods in the class, including the inherited ones, as well as the inherited and local public methods of its nested, anonymous, and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of public methods in the namespace, including the public methods of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of public methods in the component, including the public methods of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNPST">
    <name>Total Number of Public Structures (TNPST) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of public structures in the namespace, including the public structures of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of public structures in the component, including the public structures of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNPUN">
    <name>Total Number of Public Unions (TNPUN) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of public unions in the namespace, including the public unions of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of public unions in the component, including the public unions of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNS">
    <name>Total Number of Setters (TNS) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Union, Interface:&lt;/strong&gt; number of setter methods in the class, including the inherited ones, as well as the inherited and local setter methods of its nested, anonymous and local classes.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of setter methods in the namespace, including the setter methods of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of setter methods in the component, including the setter methods of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNST">
    <name>Total Number of Structures (TNST) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of structures in the namespace, including the structures of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of structures in the component, including the structures of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TNUN">
    <name>Total Number of Unions (TNUN) Metric Threshold Violation</name>
    <description>Placeholder</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TPDA">
    <name>Total Public Documented API (TPDA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of documented public classes and methods in the namespace, including the documented public classes and methods of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of documented public classes and methods in the component, including the documented public classes and methods of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_TPUA">
    <name>Total Public Undocumented API (TPUA) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Namespace:&lt;/strong&gt; number of undocumented public classes and methods in the namespace, including the undocumented public classes and methods of its subnamespaces.&lt;/p&gt;&#x0A;&lt;p&gt;&lt;strong&gt;Component:&lt;/strong&gt; number of undocumented public classes and methods in the component, including the undocumented public classes and methods of its subcomponents.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_WMC">
    <name>Weighted Methods per Class (WMC) Metric Threshold Violation</name>
    <description>&lt;p&gt;&lt;strong&gt;Class, Structure, Interface:&lt;/strong&gt; complexity of the class expressed as the number of independent control flow paths in it. It is calculated as the sum of the McCabe’s Cyclomatic Complexity (McCC) values of its local methods.&lt;/p&gt;&#x0A;</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CA">
    <name>Clone Age (CA) Metric Threshold Violation</name>
    <description>&lt;b&gt;Clone class/clone instance:&lt;/b&gt; number of previously analyzed revisions in which the clone class/clone instance was present + 1.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CC">
    <name>Clone Coverage (CC) Metric Threshold Violation</name>
    <description>&lt;b&gt;Method/Function/Union/Enum/class/Structure/Namespace:&lt;/b&gt; ratio of code covered by code duplications in the source code element to the size of the source code element, expressed in terms of the number of syntactic entities (statements, expressions, etc.).&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; ratio of code covered by code duplications in the component to the size of the component, expressed in terms of the number of syntactic entities (statements, expressions, etc.).</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CCL">
    <name>Clone Classes (CCL) Metric Threshold Violation</name>
    <description>&lt;b&gt;Method/class/package:&lt;/b&gt; number of clone classes having at least one clone instance in the source code element.&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; number of clone classes having at least one clone instance in the component.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CCO">
    <name>Clone Complexity (CCO) Metric Threshold Violation</name>
    <description>&lt;b&gt;Clone instance:&lt;/b&gt; the McCabe complexity of the code fragment corresponding to the clone instance.&lt;br&gt;&lt;b&gt;Clone class:&lt;/b&gt; sum of CCO of clone instances in the clone class.&lt;br&gt;&lt;b&gt;Function/method/class/module/package:&lt;/b&gt; sum of CCO of clone instances in the source code element.&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; sum of CCO of clone instances in the component.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CE">
    <name>Clone Embeddedness (CE) Metric Threshold Violation</name>
    <description>&lt;b&gt;Clone instance:&lt;/b&gt; sum of incoming and outgoing references (function calls, variable references, type references; different references to the same entity are counted only once) in the code fragment corresponding to the clone instance, weighted with the number of directory changes between the referenced code fragments.&lt;br&gt;&lt;b&gt;Clone class:&lt;/b&gt; sum of CE of the clone instances of the clone class + 1.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CEE">
    <name>Clone Elimination Effort (CEE) Metric Threshold Violation</name>
    <description>&lt;b&gt;Clone class:&lt;/b&gt; index of the effort required to eliminate the clone class. It is computed as the product of CI, CE, and NCR.&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; index of the effort required to eliminate all clones from the component. It is computed as the sum of CEE of the clone classes in the component.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CEG">
    <name>Clone Elimination Gain (CEG) Metric Threshold Violation</name>
    <description>&lt;b&gt;Clone class:&lt;/b&gt; index of the gain resulting from eliminating the clone class. It is computed as the ratio of CR to CEE.&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; index of the gain resulting from eliminating all clones from the component. It is computed as the logistic function of the ratio of CR to CEE.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CI">
    <name>Clone Instances (CI) Metric Threshold Violation</name>
    <description>&lt;b&gt;Method/class/package:&lt;/b&gt; number of clone instances in the source code element.&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; number of clone instances in the component.&lt;br&gt;&lt;b&gt;Clone class:&lt;/b&gt; number of clone instances in the clone class.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CLC">
    <name>Clone Line Coverage (CLC) Metric Threshold Violation</name>
    <description>&lt;b&gt;Function/method/class/module/package:&lt;/b&gt; ratio of code covered by code duplications in the source code element to the size of the source code element, expressed in terms of lines of code.&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; ratio of code covered by code duplications in the component to the size of the component, expressed in terms of lines of code.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CLLC">
    <name>Clone Logical Line Coverage (CLLC) Metric Threshold Violation</name>
    <description>&lt;b&gt;Function/method/class/module/package:&lt;/b&gt; ratio of code covered by code duplications in the source code element to the size of source code element, expressed in terms of logical lines of code (non-empty, non-comment lines).&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; ratio of code covered by code duplications in the component to the size of the component, expressed in terms of logical lines of code (non-empty, non-comment lines).</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CLLOC">
    <name>Clone Lines of Code (CLLOC) Metric Threshold Violation</name>
    <description>&lt;b&gt;Clone instance:&lt;/b&gt; length of the clone instance expressed in terms of lines of code.&lt;br&gt;&lt;b&gt;Clone class:&lt;/b&gt;  average of CLLOC of clone instances belonging to the clone class.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CR">
    <name>Clone Risk (CR) Metric Threshold Violation</name>
    <description>&lt;b&gt;Clone class:&lt;/b&gt; risk index of the existence of the clone class. It is computed as the product of CLLOC, CI, CCO, NCR, and CV.&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; relative risk index of the existence of code duplications in the component. It is computed as the sum of CR of the clone classes in the component, divided by the total logical lines of code (non-empty, non-comment lines) of the component. It expresses the risk index projected to a non-empty, non-comment line of code in the component.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_CV">
    <name>Clone Variability (CV) Metric Threshold Violation</name>
    <description>&lt;b&gt;Clone instance:&lt;/b&gt; instability of the clone instance since it appeared. It is computed as the ratio of the number of previously analyzed revisions when the instance had been changed to its age (CA).&lt;br&gt;&lt;b&gt;Clone class:&lt;/b&gt; instability of the clone class since it appeared. It is computed as the ratio of the number of previously analyzed revisions when its contained instances were moved, deleted, or added, to its age (CA), plus the average CV of its clone instances.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_LDC">
    <name>Lines of Duplicated Code (LDC) Metric Threshold Violation</name>
    <description>&lt;b&gt;Function/method/class/module/package:&lt;/b&gt; number of code lines covered by code duplications in the source code element.&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; number of code lines covered by code duplications in the component.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "MET_LLDC">
    <name>Logical Lines of Duplicated Code (LLDC) Metric Threshold Violation</name>
    <description>&lt;b&gt;Function/method/class/module/package:&lt;/b&gt; number of logical code lines (non-empty, non-comment lines) covered by code duplications in the source code element.&lt;br&gt;&lt;b&gt;Component:&lt;/b&gt; The number of logical code lines (non-empty, non-comment lines) covered by code duplications in the component.</description>
    <priority>INFO</priority>
  </rule>
  <rule key = "CEBV">
    <name>Catching Non Primitive Type Exceptions By Value</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;Reference should be used for catching a non primitive type exception.&lt;/p&gt;&#x0A;&lt;hr/&gt;&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "HP">
    <name>Hidden Parameter</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;Local variables can hide the parameters of the function, because the local variables are defined in the closest scope. It causes those parameters unreachable.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IL">
    <name>Member Init Order</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;The evaluation order in the constructor initialization list does not match the order they listed. It may cause unexpected effects like use of uninitialized class members.&lt;/p&gt;&#x0A;&lt;p&gt;For example the member ‘a’ will be uninitialized when passed to the ‘Bar’ constructor, because the initialization order is the following: ‘Bar’ constructor call, ‘a’, ‘b’.&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Foo : &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Bar {&#x0A;  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a;&#x0A;  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; b;&#x0A;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:&#x0A;  Foo (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; param) : b(param), a(b), Bar(a) {&#x0A;    ...&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;&lt;hr/&gt;&lt;h3&gt;Cppcheck&lt;/h3&gt;Member variable &apos;class::variable&apos; is in the wrong place in the initializer list. Members are initialized in the order they are declared, not in the order they are in the initializer list.  Keeping the initializer list in the same order that the members were declared prevents order dependent initialization errors.</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "MVDUD">
    <name>Missing Virtual Destructor Using Delete</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;When using pointers, make sure that the class of the pointer type has virtual destructor if any of its accessible descendant has destructor.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "MVDUN">
    <name>Missing Virtual Destructor Using New</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;When using pointers, make sure that the class of the pointer type has virtual destructor if any of its descendant has destructor.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "NDEO">
    <name>Not Defined Evaluation Order</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;The order that operands and function parameters are evaluated is unspecified behavior.&lt;/p&gt;&#x0A;&lt;p&gt;For example in the following function call, the value of the first and second arguments could be (4, 5) or (5, 4).&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;&#x0A;foo(++i, ++i);&lt;/code&gt;&lt;/pre&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "NPIFCT">
    <name>Not Public Inheritance From Catch Type</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;Not publicly derived class from a type that appears in a catch clause. This class cannot be caught in the catch clause as that base class, because no public conversion exists.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "OETS">
    <name>Check For Self Assignment In Assignment Operator</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;Missing check for self assignment in assignment operator&lt;/p&gt;&#x0A;&lt;p&gt;For example in the following operator the ‘rhs._data’ will be no longer a valid object if it is a self assignment.&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;Foo&amp;amp; &lt;span class=&quot;kw&quot;&gt;operator&lt;/span&gt;= (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Foo&amp;amp; rhs) {&#x0A;  &lt;span class=&quot;kw&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;_data;&#x0A;  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;_data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Bar(*rhs._data);&#x0A;  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;&lt;p&gt;A simple solution to this problem:&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;Foo&amp;amp; &lt;span class=&quot;kw&quot;&gt;operator&lt;/span&gt;= (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Foo&amp;amp; rhs) {&#x0A;  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; == &amp;amp;rhs) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;;&#x0A;  &lt;span class=&quot;kw&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;_data;&#x0A;  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;_data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Bar(*rhs._data);&#x0A;  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;&lt;hr/&gt;&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;‘operator=’ should check for assignment to self to ensure that each block of dynamically allocated memory is owned and managed by only one instance of the class.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SA">
    <name>Self Assignment</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;Avoid assign an object to itself.&lt;hr/&gt;&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Redundant assignment of ‘varname’ to itself.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SDANSIH">
    <name>Static Data At Namespace Scope In Header</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;Static data at namespace scope in header files generates one instance inside each compilation unit. It cause bigger executables.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SENIP">
    <name>Std::exception Not Inherited Publicly</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;Not publicly derived class from std::exception cannot be caught in the catch clause as std::exception, because no public conversion exists.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "UDINIH">
    <name>Using Directive In Namespace In Header</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;“using namespace” should not occour at namespace level in a header.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ULTZ">
    <name>Unsigned Compare Less Than Zero</name>
    <description>&lt;h3&gt;FaultHunterCPP&lt;/h3&gt;&lt;p&gt;Pointless comparison of unsigned integer against zero.&lt;/p&gt;&#x0A;&lt;hr/&gt;&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The unsigned variable ‘varname’ will never be negative so it is either pointless or an error to check if it is.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "AATI">
    <name>Assignment Address To Integer</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t).&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "ABTF">
    <name>Assign Bool To Float</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Boolean value assigned to floating point variable.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "ABTP">
    <name>Assign Bool To Pointer</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Boolean value assigned to pointer.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "AIA">
    <name>Assignment In Assert</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Variable ‘var’ is modified insert assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "AID">
    <name>Autovar Invalid Deallocation</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The deallocation of an auto-variable results in undefined behaviour. You should only free memory that has been allocated dynamically.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "AIE">
    <name>Assign If Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Mismatching assignment and comparison, comparison ’’ is always false.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "AIOOBC">
    <name>Array Index Out Of Bounds Cond</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Array ‘x[10]’ accessed at index 20, which is out of bounds. Otherwise condition ‘y==20’ is redundant.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "AITA">
    <name>Assignment Integer To Address</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t).&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "AITC">
    <name>Array Index Then Check</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Defensive programming: The variable ‘index’ is used as an array index before it is checked that is within limits. This can mean that the array might be accessed out of bounds. Reorder conditions such as ‘(a[i] &amp;amp;&amp;amp; i &amp;lt; 10)’ to ‘(i &amp;lt; 10 &amp;amp;&amp;amp; a[i])’. That way the array will not be accessed if the index is out of limits.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "AOOVP">
    <name>Arith Operations On Void Pointer</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;‘varname’ is of type ‘vartype’. When using void pointers in calculations, the behaviour is undefined. Arithmetic operations on ‘void *’ is a GNU C extension, which defines the ‘sizeof(void)’ to be 1.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "AS">
    <name>Argument Size</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The array ‘array’ is too small, the function ‘function’ expects a bigger one.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "AV">
    <name>Auto Variables</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Dangerous assignment - the function parameter is assigned the address of a local auto-variable. Local auto-variables are reserved from the stack which is freed when the function ends. So the pointer to a local variable is invalid after the function ends.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "AWSE">
    <name>Assert With Side Effect</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non-pure function: ‘function’ is called inside assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "BAOOB">
    <name>Buffer Access Out Of Bounds</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Buffer is accessed out of bounds: buffer&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "BFE">
    <name>Boost Foreach Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;BOOST_FOREACH caches the end() iterator. It’s undefined behavior if you modify the container inside.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "BNZT">
    <name>Buffer Not Zero Terminated</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The buffer ‘buffer’ is not null-terminated after the call to strncpy(). This will cause bugs later in the code if the code assumes the buffer is null-terminated.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "BOB">
    <name>Bitwise On Boolean</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Boolean variable ‘varname’ is used in bitwise operation. Did you mean ‘&amp;amp;&amp;amp;’?&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CAI">
    <name>Char Array Index</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Signed ‘char’ type used as array index. If the value can be greater than 127 there will be a buffer underflow because of sign extension.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "CATIAR">
    <name>Cast Address To Integer At Return</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Returning an address value in a function with integer (int/long/etc) return type is not portable across different platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in 64-bit Windows and Linux they are of different width. In worst case you end up casting 64-bit address down to 32-bit integer. The safe way is to always return an integer.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CBEWI">
    <name>Compare Bool Expression With Int</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Comparison of a boolean expression with an integer other than 0 or 1.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "CBO">
    <name>Char Bit Op</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;When using ‘char’ variables in bit operations, sign extension can generate unexpected results.&lt;/p&gt;&#x0A;&lt;p&gt;For example:&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; c = &lt;span class=&quot;bn&quot;&gt;0x80&lt;/span&gt;;&#x0A;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; | c;&#x0A;&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (i &amp;amp; &lt;span class=&quot;bn&quot;&gt;0x8000&lt;/span&gt;)&#x0A;  printf(&lt;span class=&quot;st&quot;&gt;&amp;quot;not expected&amp;quot;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&#x0A;&lt;p&gt;The “not expected” will be printed on the screen.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "CCALC">
    <name>Clarify Calculation</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Suspicious calculation. Please use parentheses to clarify the code. The code ‘’a+b?c:d’‘should be written as either’‘(a+b)?c:d’‘or’‘a+(b?c:d)’’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CCITCAB">
    <name>Check Cast Int To Char And Back</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;When saving func_name() return value in char variable there is loss of precision. When func_name() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop “while (EOF != (c = func_name());” loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "CCM">
    <name>Cout Cerr Misusage</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Invalid usage of output stream: ‘&amp;lt;&amp;lt; std::cout’.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "CCOND">
    <name>Clarify Condition</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Suspicious condition (assignment + comparison); Clarify expression with parentheses.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CCPC">
    <name>Copy Ctor Pointer Copying</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Value of pointer ‘var’, which points to allocated memory, is copied in copy constructor instead of allocating new memory.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CE">
    <name>Comparison Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The expression ‘(X &amp;amp; 0x6) == 0x1’ is always false. Check carefully constants and operators used, these errors might be hard to spot sometimes. In case of complex expression it might help to split it to separate expressions.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CFIATOF">
    <name>Comparison Function Is Always True Or False</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The function isless is designed to compare two variables. Calling this function with one variable (varName) for both parameters leads to a statement which is always false.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "CITAAR">
    <name>Cast Integer To Address At Return</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Returning an integer (int/long/etc) in a function with pointer return type is not portable across different platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in 64-bit Windows and Linux they are of different width. In worst case you end up casting 64-bit integer down to 32-bit pointer. The safe way is to always return a pointer.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CLWCPC">
    <name>Char Literal With Char Ptr Compare</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Char literal compared with pointer ‘foo’. Did you intend to dereference it?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "COBWBE">
    <name>Comparison Of Bool With Bool Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The variable ‘var_name’ is of type ‘bool’ and comparing ‘bool’ value using relational (&amp;lt;, &amp;gt;, &amp;lt;= or &amp;gt;=) operator could cause unexpected results.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "COBWI">
    <name>Comparison Of Bool With Int</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The expression ‘varname’ is of type ‘bool’ and it is compared against an integer value that is neither 1 nor 0.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "COBWIC">
    <name>Comparison Of Bool With Invalid Comparator</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The result of the expression ‘varname’ is of type ‘bool’. Comparing ‘bool’ value using relational (&amp;lt;, &amp;gt;, &amp;lt;= or &amp;gt;=) operator could cause unexpected results.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "COFRBE">
    <name>Comparison Of Func Returning Bool Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The return type of function ‘func_name’ is ‘bool’ and result is of type ‘bool’. Comparing ‘bool’ value using relational (&amp;lt;, &amp;gt;, &amp;lt;= or &amp;gt;=) operator could cause unexpected results.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "COTFRBE">
    <name>Comparison Of Two Funcs Returning Bool Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The return type of function ‘func_name1’ and function ‘func_name2’ is ‘bool’ and result is of type ‘bool’. Comparing ‘bool’ value using relational (&amp;lt;, &amp;gt;, &amp;lt;= or &amp;gt;=) operator could cause unexpected results.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CS">
    <name>Const Statement</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Redundant code: Found a statement that begins with type constant.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "CSC">
    <name>Cstyle Cast</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected.&lt;/p&gt;&#x0A;&lt;p&gt;See also: &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts&quot; class=&quot;uri&quot;&gt;https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts&lt;/a&gt;.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CSR">
    <name>Comma Separated Return</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Comma is used in return statement. When comma is used in a return statement it can easily be misread as a semicolon.&lt;/p&gt;&#x0A;&lt;p&gt;For example in the code below the value of ‘b’ is returned if the condition is true, but it is easy to think that ‘a+1’ is returned:&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (x)&#x0A;  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; a + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, b++;&lt;/code&gt;&lt;/pre&gt;&#x0A;&lt;p&gt;However it can be useful to use comma in macros. Cppcheck does not warn when such a macro is then used in a return statement, it is less likely such code is misunderstood.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "CSTAT">
    <name>Clarify Statement</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;A statement like &lt;code&gt;*A++;&lt;/code&gt; might not do what you intended. Postfix &lt;code&gt;operator++&lt;/code&gt; is executed before &lt;code&gt;operator*&lt;/code&gt;. Thus, the dereference is meaningless. Did you intend to write &lt;code&gt;(*A)++;&lt;/code&gt;?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "DAR">
    <name>Deallocret</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Returning/dereferencing ‘p’ after it is deallocated / released&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "DBRANCH">
    <name>Duplicate Branch</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Finding the same code in an ‘if’ and related ‘else’ branch is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "DBREAK">
    <name>Duplicate Break</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "DCD">
    <name>Double Close Dir</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Directory handle ‘varname’ closed twice.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "DD">
    <name>Dealloc Dealloc</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Deallocating a deallocated pointer: varname&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "DEXPR">
    <name>Duplicate Expression</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "DF">
    <name>Double Free</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Memory pointed to by ‘varname’ is freed twice.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "DII">
    <name>Deref Invalid Iterator</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Make sure to check that the iterator is valid before dereferencing it - not after.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "DIM">
    <name>Dupl Inherited Member</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The class ‘class’ defines member variable with name ‘variable’ also defined in its parent class ‘class’.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "DP">
    <name>Deadpointer</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Dead pointer usage. Pointer ‘pointer’ is dead if it has been assigned ‘&amp;amp;x’ at line 0.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "DSO">
    <name>Divide Sizeof</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Division of result of sizeof() on pointer type. sizeof() returns the size of the pointer, not the size of the memory area it points to.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "DU">
    <name>Deallocuse</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Dereferencing ‘varname’ after it is deallocated / released&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "ED">
    <name>Erase Dereference</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The iterator ‘iter’ is invalid before being assigned. Dereferencing or comparing it with another iterator is invalid operation.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "EDT">
    <name>Except Dealloc Throw</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Exception thrown in invalid state, ‘p’ points at deallocated memory.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ERC">
    <name>Except Rethrow Copy</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Rethrowing an exception with ‘throw varname;’ creates an unnecessary copy of ‘varname’. To rethrow the caught exception without unnecessary copying or slicing, use a bare ‘throw;’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "ETIANTF">
    <name>Except Throw In Attribute No Throw Function</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Exception thrown in __attribute__((nothrow)) function.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "ETID">
    <name>Except Throw In Destructor</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The class Class is not safe because its destructor throws an exception. If Class is used and an exception is thrown that is caught in an outer scope the program will terminate.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ETIDNTF">
    <name>Except Throw In Declspec No Throw Function</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Exception thrown in __declspec(nothrow) function.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "ETINF">
    <name>Except Throw In Noexecpt Function</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Exception thrown in noexcept function.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "ETINTF">
    <name>Except Throw In No Throw Function</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Exception thrown in throw() function.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "FC">
    <name>Function Const</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The member function ‘class::function’ can be made a const function. Making this function ‘const’ should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state?&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "FOIS">
    <name>Fflush On Input Stream</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;fflush() called on input stream ‘stdin’ may result in undefined behaviour on non-linux systems.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "FS">
    <name>Function Static</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The member function ‘class::function’ can be made a static function. Making a function static can bring a performance benefit since no ‘this’ instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances?&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "IAF">
    <name>Incomplete Array Fill</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The array ‘buffer’ is filled incompletely. The function ‘memset()’ needs the size given in bytes, but an element of the given array is larger than one byte. Did you forget to multiply the size with ‘sizeof(*buffer)’?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IB">
    <name>Increment Boolean</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The operand of a postfix increment operator may be of type bool but it is deprecated by C++ Standard (Annex D-1) and the operand is always set to true. You should assign it the value ‘true’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "ICLA">
    <name>Insecure Cmd Line Args</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Buffer overrun possible for long command line arguments.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "IF">
    <name>Invalid Free</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Invalid memory address freed.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "IFA">
    <name>Invalid Function Arg</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Invalid func_name() argument nr 1&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "IFAB">
    <name>Invalid Function Arg Bool</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Invalid func_name() argument nr 1. A non-boolean value is required.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "IIT">
    <name>Invalid Iterator1</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Invalid iterator: iterator&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "IIT2">
    <name>Invalid Iterator2</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;After push_back|push_front|insert(), the iterator ‘iterator’ may be invalid.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "ILME">
    <name>Invalid Length Modifier Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;‘modifier’ in format string (no. number) is a length modifier and cannot be used without a conversion specifier.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ILO">
    <name>Incorrect Logic Operator</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Logical disjunction always evaluates to true: foo &amp;gt; 3 &amp;amp;&amp;amp; foo &amp;lt; 4. Are these conditions necessary? Did you intend to use &amp;amp;&amp;amp; instead? Are the numbers correct? Are you comparing the correct variables?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IO">
    <name>Integer Overflow</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Signed integer overflow for expression ’’&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "IOWP">
    <name>IO Without Positioning</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "IP">
    <name>Invalid Pointer</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Invalid pointer ‘pointer’ after push_back().&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "IPATF">
    <name>Invalid Printf Arg Type_float</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%f in format string (no. 1) requires ‘double’ but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IPATI">
    <name>Invalid Printf Arg Type_int</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%X in format string (no. 1) requires ‘unsigned int’ but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IPATN">
    <name>Invalid Printf Arg Type_n</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%n in format string (no. 1) requires ‘int *’ but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IPATP">
    <name>Invalid Printf Arg Type_p</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%p in format string (no. 1) requires an address but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IPATS">
    <name>Invalid Printf Arg Type_s</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%s in format string (no. 1) requires ‘char *’ but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IPATSI">
    <name>Invalid Printf Arg Type_sint</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%i in format string (no. 1) requires ‘int’ but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IPATUI">
    <name>Invalid Printf Arg Type_uint</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%u in format string (no. 1) requires ‘unsigned int’ but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IPC">
    <name>Invalid Pointer Cast</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Casting between float* and double* which have an incompatible binary data representation.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "IRV">
    <name>Ignored Return Value</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Return value of function malloc() is not used.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "IS">
    <name>Invalid Scanf</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem: %s =&amp;gt; %20s.&lt;/p&gt;&#x0A;&lt;p&gt;Sample program that can crash:&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&#x0A;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()&#x0A;{&#x0A;  &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; c[&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;];&#x0A;  scanf(&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;, c);&#x0A;  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;&lt;p&gt;Typing in 5 or more characters may make the program crash. The correct usage here is ‘scanf(“%4s”, c);’, as the maximum field width does not include the terminating null byte.&lt;/p&gt;&#x0A;&lt;p&gt;Source: &lt;a href=&quot;http://linux.die.net/man/3/scanf&quot; class=&quot;uri&quot;&gt;http://linux.die.net/man/3/scanf&lt;/a&gt;&lt;/p&gt;&#x0A;&lt;p&gt;Source: &lt;a href=&quot;http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c&quot; class=&quot;uri&quot;&gt;http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c&lt;/a&gt;&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ISATF">
    <name>Invalid Scanf Arg Type_float</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%f in format string (no. 1) requires ‘float *’ but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ISATI">
    <name>Invalid Scanf Arg Type_int</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%d in format string (no. 1) requires ‘int *’ but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ISATS">
    <name>Invalid Scanf Arg Type_s</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;%s in format string (no. 1) requires a ‘char *’ but the argument type is Unknown.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ISBE">
    <name>Incorrect String Boolean Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Conversion of string literal “Hello World” to bool always evaluates to true.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ISC">
    <name>Incorrect String Compare</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;String literal “Hello World” doesn’t match length argument for substr().&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ISFW">
    <name>Invalid Scanf Format Width</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Width 5 given in format string (no. 10) is larger than destination buffer ‘[0]’, use %-1s to prevent overflowing it.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "ISFWS">
    <name>Invalid Scanf Format Width_smaller</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Width 5 given in format string (no. 10) is smaller than destination buffer ‘varname[arrlen]’.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "ISL">
    <name>Invalid Scanf LibC</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;scanf without field width limits can crash with huge input data on libc versions older than 2.13-25. Add a field width specifier to fix this problem: %i =&amp;gt; %3i.&lt;/p&gt;&#x0A;&lt;p&gt;Sample program that can crash:&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&#x0A;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()&#x0A;{&#x0A;  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a;&#x0A;  scanf(&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%i&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;, &amp;amp;a);&#x0A;  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;&lt;p&gt;To make it crash: perl -e ‘print “5”x2100000’ | ./a.out&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "IT">
    <name>Iterators</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Same iterator is used with different containers ‘container1’ and ‘container2’.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "LNVFC">
    <name>Leak No Var Function Call</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Allocation with funcName, funcName doesn’t release it.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "LWCPC">
    <name>Literal With Char Ptr Compare</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;String literal compared with variable ‘foo’. Did you intend to use strcmp() instead?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "MAD">
    <name>Mismatch Alloc Dealloc</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Mismatching allocation and deallocation: varname&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "MATF">
    <name>Modulo Always True False</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Comparison of modulo result is predetermined, because it is always less than 1.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "MBA">
    <name>Mismatching Bit And</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Mismatching bitmasks. Result is always 0 (X = Y &amp;amp; 0xf0; Z = X &amp;amp; 0x1; =&amp;gt; Z=0).&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "MC">
    <name>Memset Class</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Using ‘memfunc’ on class that contains a classname is unsafe, because constructor, destructor and copy operator calls are omitted. These are necessary for this non-POD type to ensure that a valid object is created.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "MCF">
    <name>Memset Class Float</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Using memset() on class which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "MCOND">
    <name>Multi Condition</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Expression is always false because ‘else if’ condition matches previous condition at line 1.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "MCR">
    <name>Memset Class Reference</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Using ‘memfunc’ on class that contains a reference.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "MF">
    <name>Memset Float</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The 2nd memset() argument ‘varname’ is a float, its representation is implementation defined. memset() is used to set each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "ML">
    <name>Memleak</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Memory leak: varname&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "MMC">
    <name>Mismatching Containers</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Iterators of different containers are used together.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "MOCE">
    <name>Malloc On Class Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Memory for class instance allocated with malloc(), but class a std::string. This is unsafe, since no constructor is called and class members remain uninitialized. Consider using ‘new’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "MOCW">
    <name>Malloc On Class Warning</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Memory for class instance allocated with malloc(), but class provides constructors. This is unsafe, since no constructor is called and class members remain uninitialized. Consider using ‘new’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "MOR">
    <name>Memleak On Realloc</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Common realloc mistake: ‘varname’ nulled but not freed upon failure&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "MS">
    <name>Mismatch Size</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The allocated size sz is not a multiple of the underlying type’s size.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "MSO">
    <name>Multiply Sizeof</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Multiplying sizeof() with sizeof() indicates a logic error.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "MVOOR">
    <name>Memset Value Out Of Range</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The 2nd memset() argument ‘varname’ doesn’t fit into an ‘unsigned char’. The 2nd parameter is passed as an ‘int’, but the function fills the block of memory using the ‘unsigned char’ conversion of this value.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "MZB">
    <name>Memset Zero Bytes</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;memset() called to fill 0 bytes of ‘varname’. The second and third arguments might be inverted. The function memset ( void * ptr, int value, size_t num ) sets the first num bytes of the block of memory pointed by ptr to the specified value.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "NC">
    <name>No Constructor</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The class ‘classname’ does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NCC">
    <name>No Copy Constructor</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;‘class class’ does not have a copy constructor which is recommended since the class contains a pointer to allocated memory.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NI">
    <name>Negative Index</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Array index -1 is out of bounds.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "NIAE">
    <name>Nan In Arithmetic Expression</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Using NaN/Inf in a computation. Although nothing bad really happens, it is suspicious.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NMAS">
    <name>Negative Memory Allocation Size</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Memory allocation size is negative.Negative allocation size has no specified behaviour.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "NP">
    <name>Null Pointer</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Possible null pointer dereference: pointer&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "NRFCR">
    <name>Nonreentrant Functions crypt</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘crypt’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘crypt_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFCT">
    <name>Nonreentrant Functions ctermid</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘ctermid’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘ctermid_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFEC">
    <name>Nonreentrant Functions ecvt</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘ecvt’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘ecvt_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFFC">
    <name>Nonreentrant Functions fcvt</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘fcvt’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘fcvt_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFFGG">
    <name>Nonreentrant Functions fgetgrent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘fgetgrent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘fgetgrent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFFGP">
    <name>Nonreentrant Functions fgetpwent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘fgetpwent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘fgetpwent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFFGS">
    <name>Nonreentrant Functions fgetspent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘fgetspent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘fgetspent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGC">
    <name>Nonreentrant Functions gcvt</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘gcvt’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘gcvt_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGG">
    <name>Nonreentrant Functions getgrent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getgrent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getgrent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGGG">
    <name>Nonreentrant Functions getgrgid</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getgrgid’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getgrgid_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGGN">
    <name>Nonreentrant Functions getgrnam</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getgrnam’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getgrnam_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGH">
    <name>Nonreentrant Functions gethostent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘gethostent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘gethostent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGHBA">
    <name>Nonreentrant Functions gethostbyaddr</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘gethostbyaddr’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘gethostbyaddr_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGHBN">
    <name>Nonreentrant Functions gethostbyname</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘gethostbyname’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘gethostbyname_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGHBN2">
    <name>Nonreentrant Functions gethostbyname2</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘gethostbyname2’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘gethostbyname2_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGL">
    <name>Nonreentrant Functions getlogin</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getlogin’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getlogin_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGMT">
    <name>Nonreentrant Functions gmtime</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘gmtime’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘gmtime_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGNBA">
    <name>Nonreentrant Functions getnetbyaddr</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getnetbyaddr’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getnetbyaddr_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGNBN">
    <name>Nonreentrant Functions getnetbyname</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getnetbyname’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getnetbyname_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGNG">
    <name>Nonreentrant Functions getnetgrent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getnetgrent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getnetgrent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGPBN">
    <name>Nonreentrant Functions getprotobyname</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getprotobyname’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getprotobyname_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGPE">
    <name>Nonreentrant Functions getpwent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getpwent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getpwent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGPN">
    <name>Nonreentrant Functions getpwnam</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getpwnam’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getpwnam_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGPU">
    <name>Nonreentrant Functions getpwuid</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getpwuid’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getpwuid_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGRBNA">
    <name>Nonreentrant Functions getrpcbyname</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getrpcbyname’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getrpcbyname_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGRBNU">
    <name>Nonreentrant Functions getrpcbynumber</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getrpcbynumber’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getrpcbynumber_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGRP">
    <name>Nonreentrant Functions getrpcent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getrpcent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getrpcent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGS">
    <name>Nonreentrant Functions getservent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getservent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getservent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGSBN">
    <name>Nonreentrant Functions getservbyname</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getservbyname’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getservbyname_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGSBP">
    <name>Nonreentrant Functions getservbyport</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getservbyport’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getservbyport_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGSE">
    <name>Nonreentrant Functions getspent</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getspent’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getspent_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFGSN">
    <name>Nonreentrant Functions getspnam</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘getspnam’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘getspnam_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFLT">
    <name>Nonreentrant Functions localtime</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘localtime’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘localtime_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFRD">
    <name>Nonreentrant Functions readdir</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘readdir’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘readdir_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFST">
    <name>Nonreentrant Functions strtok</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘strtok’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘strtok_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFTN">
    <name>Nonreentrant Functions tempnam</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘tempnam’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘tempnam_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "NRFTTYN">
    <name>Nonreentrant Functions ttyname</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Non reentrant function ‘ttyname’ called. For threadsafe applications it is recommended to use the reentrant replacement function ‘ttyname_r’.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OE">
    <name>Operator Eq</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The class::operator= does not conform to standard C/C++ behaviour. To conform to standard C/C++ behaviour, return a reference to self (such as: &lt;code&gt;class &amp;amp;class::operator=(..) { .. return *this; }&lt;/code&gt;. For safety reasons it might be better to not fix this message. If you think that safety is always more important than conformance then please ignore/suppress this message. For more details about this topic, see the book “Effective C++” by Scott Meyers.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OERRT">
    <name>Operator Eq Ret Ref This</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;‘operator=’ should return reference to ‘this’ instance.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OEVE">
    <name>Operator Eq Var Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Member variable ‘classname::’ is not assigned a value in ‘classname::operator=’.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "OFA">
    <name>Obsolete Functions asctime_r</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘asctime_r’ called. It is recommended to use the function ‘strftime’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFAA">
    <name>Obsolete Functions alloca</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The obsolete function ‘alloca’ is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function ‘alloca’ is dangerous for many reasons (&lt;a href=&quot;http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice&quot; class=&quot;uri&quot;&gt;http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice&lt;/a&gt; and &lt;a href=&quot;http://linux.die.net/man/3/alloca&quot; class=&quot;uri&quot;&gt;http://linux.die.net/man/3/alloca&lt;/a&gt;).&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFAT">
    <name>Obsolete Functions asctime</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘asctime’ called. It is recommended to use the function ‘strftime’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFBCMP">
    <name>Obsolete Functions bcmp</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘bcmp’ called. It is recommended to use the function ‘memcmp’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFBCPY">
    <name>Obsolete Functions bcopy</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘bcopy’ called. It is recommended to use the ‘memmove’ or ‘memcpy’ function instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFBSS">
    <name>Obsolete Functions bsd_signal</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘bsd_signal’ called. It is recommended to use the function ‘sigaction’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFBZ">
    <name>Obsolete Functions bzero</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘bzero’ called. It is recommended to use the function ‘memset’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFCT">
    <name>Obsolete Functions ctime_r</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘ctime_r’ called. It is recommended to use the function ‘strftime’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFECVT">
    <name>Obsolete Functions ecvt</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘ecvt’ called. It is recommended to use the function ‘sprintf’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFFCVT">
    <name>Obsolete Functions fcvt</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘fcvt’ called. It is recommended to use the function ‘sprintf’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFFT">
    <name>Obsolete Functions ftime</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘ftime’ called. It is recommended to use time(), gettimeofday() or clock_gettime() instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFGC">
    <name>Obsolete Functions getcontext</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘getcontext’ called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFGCVT">
    <name>Obsolete Functions gcvt</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘gcvt’ called. It is recommended to use the function ‘sprintf’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFGHBA">
    <name>Obsolete Functions gethostbyaddr</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘gethostbyaddr’ called. It is recommended to use the function ‘getnameinfo’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFGHBN">
    <name>Obsolete Functions gethostbyname</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘gethostbyname’ called. It is recommended to use the function ‘getaddrinfo’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFGS">
    <name>Obsolete Functions gets</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The obsolete function ‘gets’ is called. With ‘gets’ you’ll get a buffer overrun if the input data exceeds the size of the buffer. It is recommended to use the function ‘fgets’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFGWD">
    <name>Obsolete Functions getwd</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘getwd’ called. It is recommended to use the function ‘getcwd’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFI">
    <name>Obsolete Functions index</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘index’ called. It is recommended to use the function ‘strchr’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFMC">
    <name>Obsolete Functions makecontext</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘makecontext’ called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFPAGSA">
    <name>Obsolete Functions pthread_attr_getstackaddr</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘pthread_attr_getstackaddr’ called. It is recommended to use the function ‘pthread_attr_getstack’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFPASSA">
    <name>Obsolete Functions pthread_attr_setstackaddr</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘pthread_attr_setstackaddr’ called. It is recommended to use the function ‘pthread_attr_setstack’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFR">
    <name>Obsolete Functions rand_r</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘rand_r’ called. It is recommended to use the function ‘rand’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFRI">
    <name>Obsolete Functions rindex</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘rindex’ called. It is recommended to use the function ‘strrchr’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFSB">
    <name>Obsolete Functions scalbln</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘scalb’ called. It is recommended to use ‘scalbln’, ‘scalblnf’ or ‘scalblnl’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFSC">
    <name>Obsolete Functions swapcontext</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘swapcontext’ called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFTN">
    <name>Obsolete Functions tmpnam</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘tmpnam’ called. It is recommended to use ‘tmpfile’, ‘mkstemp’ or ‘mkdtemp’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFTNR">
    <name>Obsolete Functions tmpnam_r</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘tmpnam_r’ called. It is recommended to use ‘tmpfile’, ‘mkstemp’ or ‘mkdtemp’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFUA">
    <name>Obsolete Functions ualarm</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘ualarm’ called. It is recommended to use ‘timer_create’, ‘timer_delete’, ‘timer_getoverrun’, ‘timer_gettime’ or ‘timer_settime’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFUS">
    <name>Obsolete Functions usleep</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The obsolete function ‘usleep’ is called. POSIX.1-2001 declares usleep() function obsolete and POSIX.1-2008 removes it. It is recommended that new applications use the ‘nanosleep’ or ‘setitimer’ function.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFUT">
    <name>Obsolete Functions utime</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘utime’ called. It is recommended to use the function ‘utimensat’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFVF">
    <name>Obsolete Functions vfork</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘vfork’ called. It is recommended to use the function ‘fork’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OFWCS">
    <name>Obsolete Functions wcswcs</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Obsolete function ‘wcswcs’ called. It is recommended to use the function ‘wcsstr’ instead.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "OIC">
    <name>Opposite Inner Condition</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Opposite conditions in nested ‘if’ blocks lead to a dead code block.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "OOB">
    <name>Out Of Bounds</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Index is out of bounds: Supplied size 2 is larger than actual size 1.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "PAB">
    <name>Pointer Arith Bool</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Converting pointer arithmetic result to bool. The boolean result is always true unless there is pointer arithmetic overflow, and overflow is undefined behaviour. Probably a dereference is forgotten.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "PAE">
    <name>Public Allocation Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Possible leak in public function. The pointer ‘varname’ is not deallocated before it is allocated.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "PBAOOB">
    <name>Possible Buffer Access Out Of Bounds</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination). The source buffer is larger than the destination buffer so there is the potential for overflowing the destination buffer.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "PBV">
    <name>Passed By Value</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Parameter ‘parametername’ is passed by value. It could be passed as a (const) reference which is usually faster and recommended in C++.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "PLTZ">
    <name>Pointer Less Than Zero</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;A pointer can not be negative so it is either pointless or an error to check if it is.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "PO">
    <name>Postfix Operator</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Prefix ++/– operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "POOB">
    <name>Pointer Out Of Bounds</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Undefined behaviour, pointer arithmetic ’’ is out of bounds. From chapter 6.5.6 in the C specification: “When an expression that has integer type is added to or subtracted from a pointer, ..” and then “If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.”&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "PP">
    <name>Pointer Positive</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;A pointer can not be negative so it is either pointless or an error to check if it is not.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "PRBO">
    <name>Possible Readlink Buffer Overrun</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;readlink() might return the full size of ‘buffer’. If a buffer[len] = ‘\0’; statement follows, it will overrun the buffer. Lower the supplied size by one.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "PS">
    <name>Pointer Size</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Size of pointer ‘varname’ used instead of size of its data. This is likely to lead to a buffer overflow. You probably intend to write ‘sizeof(*varname)’.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "PVC">
    <name>Pure Virtual Call</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Call of pure virtual function ‘func_name’ in ‘func_type_name’. The call will fail during runtime.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "RA">
    <name>Redundant Assignment</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Variable ‘var’ is reassigned a value before the old one has been used.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "RAIS">
    <name>Redundant Assign In Switch</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Variable ‘var’ is reassigned a value before the old one has been used. ‘break;’ missing?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "RAOAV">
    <name>Return Address Of Auto Variable</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Address of an auto-variable returned.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "RAOFP">
    <name>Return Address Of Function Parameter</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Address of the function parameter ‘parameter’ becomes invalid after the function exits because function parameters are stored on the stack which is freed when the function exits. Thus the returned value is invalid.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "RBOIS">
    <name>Redundant Bitwise Operation In Switch</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Redundant bitwise operation on ‘varname’ in ‘switch’ statement. ‘break;’ missing?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "RCIS">
    <name>Redundant Copy In Switch</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Buffer ‘var’ is being written before its old content has been used. ‘break;’ missing?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "RCLC">
    <name>Redundant Copy Local Const</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The const variable ‘varname’ is assigned a copy of the data. You can avoid the unnecessary data copying by converting ‘varname’ to const reference.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "RCOND">
    <name>Redundant Condition</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Redundant condition: If x &amp;gt; 11 the condition x &amp;gt; 10 is always true.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "RCPY">
    <name>Redundant Copy</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Buffer ‘var’ is being written before its old content has been used.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "REC">
    <name>Read Empty Container</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Reading from empty STL container&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "RF">
    <name>Return Reference</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Reference to auto variable returned.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "RGASUI">
    <name>Redundant Get And Set User Id</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Redundant statement without any effect. First the user id is retrieved by get(e)uid() and then set with set(e)uid().&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "RIR">
    <name>Redundant If Remove</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Redundant checking of STL container element existence before removing it. It is safe to call the remove method on a non-existing element.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "RL">
    <name>Resource Leak</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Resource leak: varname&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "RLV">
    <name>Return Local Variable</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Pointer to local array variable returned.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "RTF">
    <name>Return Temp Reference</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Reference to temporary returned.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "RWOF">
    <name>Read Write Only File</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Read operation on a file that was opened only for writing.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "SAAC">
    <name>Size Argument As Char</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The size argument is given as a char constant.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SC">
    <name>Sign Conversion</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Suspicious code: sign conversion of var in calculation, even though var can have a negative value&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SCFT">
    <name>Switch Case Fall Through</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Switch falls through case without comment. ‘break;’ missing?&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "SCP">
    <name>Stlcstr Param</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The conversion from &lt;code&gt;const char*&lt;/code&gt; as returned by c_str() to &lt;code&gt;std::string&lt;/code&gt; creates an unnecessary string copy. Solve that by directly passing the string.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "SCR">
    <name>Stlcstr Return</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly returning the string.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "SCT">
    <name>Stlcstr Throw</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Dangerous usage of c_str(). The string is destroyed after the c_str() call so the thrown pointer is invalid.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "SEC">
    <name>Suspicious Equality Comparison</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Found suspicious equality comparison. Did you intend to assign a value instead?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SI">
    <name>Self Initialization</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Member variable ‘var’ is initialized by itself.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "SN">
    <name>Shift Negative</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Shifting by a negative value is undefined behaviour&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "SOAF">
    <name>Seek On Appended File</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Repositioning operation performed on a file opened in append mode has no effect.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SOC">
    <name>Sizeof Calculation</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Found calculation inside sizeof().&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SOD">
    <name>Sprintf Overlapping Data</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The variable ‘varname’ is used both as a parameter and as destination in s[n]printf(). The origin and destination buffers overlap. Quote from glibc (C-library) documentation (&lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatted-Output-Functions&quot; class=&quot;uri&quot;&gt;http://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatted-Output-Functions&lt;/a&gt;): “If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results are undefined.”&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "SODMF">
    <name>Sizeof Division Memfunc</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Division by result of sizeof(). memset() expects a size in bytes, did you intend to multiply instead?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SODVP">
    <name>Sizeof Dereferenced Void Pointer</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;‘*varname’ is of type ‘void’, the behaviour of ‘sizeof(void)’ is not covered by the ISO C standard. A value for ‘sizeof(void)’ is defined only as part of a GNU C extension, which defines ‘sizeof(void)’ to be 1.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "SOSO">
    <name>Sizeof Sizeof</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Calling sizeof for ‘sizeof looks like a suspicious code and most likely there should be just one ’sizeof’. The current code is equivalent to ‘sizeof(size_t)’&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SOV">
    <name>Sizeof Void</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Behaviour of ‘sizeof(void)’ is not covered by the ISO C standard. A value for ‘sizeof(void)’ is defined only as part of a GNU C extension, which defines ‘sizeof(void)’ to be 1.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "SOWNP">
    <name>Sizeof With Numeric Parameter</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;It is unusual to use a constant value with sizeof. For example, ‘sizeof(10)’ returns 4 (in 32-bit systems) or 8 (in 64-bit systems) instead of 10. ‘sizeof(’A’)‘and ’sizeof(char)’ can return different results.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SOWSAP">
    <name>Sizeof With Silent Array Pointer</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Using ‘sizeof’ for array given as function argument returns the size of a pointer. It does not return the size of the whole array in bytes as might be expected.&lt;/p&gt;&#x0A;&lt;p&gt;For example, this code:&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; f(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;]) {&#x0A;  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(a);&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;&lt;p&gt;returns 4 (in 32-bit systems) or 8 (in 64-bit systems) instead of 100 (the size of the array in bytes).&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SPC">
    <name>Str Plus Char</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Unusual pointer arithmetic. A value of type ‘char’ is added to a string literal.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "SS">
    <name>Suspicious Semicolon</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Suspicious use of ; at the end of ’’ statement.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SSC">
    <name>Static String Compare</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The compared strings, ‘str1’ and ‘str2’, are always unequal. Therefore the comparison is unnecessary and looks suspicious.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "STLB">
    <name>Stl Boundaries</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Iterator of container ‘std::container’ compared with operator&amp;lt;. This is dangerous since the order of items in the container is not guaranteed. One should use operator!= instead to compare iterators.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "STLC">
    <name>Stlcstr</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Dangerous usage of c_str(). The c_str() return value is only valid until its string is deleted.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "STLIF">
    <name>Stl If Find</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Suspicious condition. The result of find() is an iterator, but it is not properly checked.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "STLISF">
    <name>Stl If Str Find</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Either inefficient or wrong usage of string::find(). string::compare() will be faster if string::find’s result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "STLMC">
    <name>Stl Missing Comparison</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The iterator incrementing is suspicious - it is incremented at line and then at line . The loop might unintentionally skip an element in the container. There is no comparison between these increments to prevent that the iterator is incremented beyond the end.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "STLOOB">
    <name>Stl Out Of Bounds</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;When i==foo.size(), foo[i] is out of bounds.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "STLS">
    <name>Stl Size</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Checking for ‘list’ emptiness might be inefficient. Using list.empty() instead of list.size() can be faster. list.size() can take linear time but list.empty() is guaranteed to take constant time.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "STMB">
    <name>Shift Too Many Bits</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Shifting 32-bit value by 64 bits is undefined behaviour&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "STRCMP">
    <name>String Compare</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The compared strings, ‘varname1’ and ‘varname2’, are identical. This could be a logic bug.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "STRCU">
    <name>Strncat Usage</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;At most, strncat appends the 3rd parameter’s amount of characters and adds a terminating null byte. The safe way to use strncat is to subtract one from the remaining space in the buffer and use it as 3rd parameter.&lt;/p&gt;&#x0A;&lt;p&gt;Source: &lt;a href=&quot;http://www.cplusplus.com/reference/cstring/strncat/&quot; class=&quot;uri&quot;&gt;http://www.cplusplus.com/reference/cstring/strncat/&lt;/a&gt;&lt;/p&gt;&#x0A;&lt;p&gt;Source: &lt;a href=&quot;http://www.opensource.apple.com/source/Libc/Libc-167/gen.subproj/i386.subproj/strncat.c&quot; class=&quot;uri&quot;&gt;http://www.opensource.apple.com/source/Libc/Libc-167/gen.subproj/i386.subproj/strncat.c&lt;/a&gt;&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "SUSPC">
    <name>Suspicious Case</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Using an operator like ‘||’ in a case label is suspicious. Did you intend to use a bitwise operator, multiple case labels or if/else instead?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "TS">
    <name>This Subtraction</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Suspicious pointer subtraction. Did you intend to write ‘-&amp;gt;’?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "TSTRC">
    <name>Terminate Strncpy</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;If the source string’s size fits or exceeds the given size, strncpy() does not add a zero at the end of the buffer. This causes bugs later in the code if the code assumes buffer is null-terminated.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "UAA">
    <name>Useless Assignment Arg</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Assignment of function parameter has no effect outside the function.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UAPA">
    <name>Use Auto Pointer Array</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Object pointed by an ‘auto_ptr’ is destroyed using operator ‘delete’. This means that you should only use ‘auto_ptr’ for pointers obtained with operator ‘new’. This excludes arrays, which are allocated by operator ‘new[]’ and must be deallocated by operator ‘delete[]’.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "UAPARG">
    <name>Useless Assignment Ptr Arg</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "UAPC">
    <name>Use Auto Pointer Container</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;An element of container must be able to be copied but ‘auto_ptr’ does not fulfill this requirement. You should consider to use ‘shared_ptr’ or ‘unique_ptr’. It is suitable for use in containers, because they no longer copy their values, they move them.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "UAPCPY">
    <name>Use Auto Pointer Copy</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;‘std::auto_ptr’ has semantics of strict ownership, meaning that the ‘auto_ptr’ instance is the sole entity responsible for the object’s lifetime. If an ‘auto_ptr’ is copied, the source looses the reference.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UAV">
    <name>Unassigned Variable</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Variable ‘varname’ is not assigned a value.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UCC">
    <name>Useless Calls Compare</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;‘std::string::find()’ returns zero when given itself as parameter (str.find(str)). As it is currently the code is inefficient. It is possible either the string searched (‘str’) or searched for (‘str’) is wrong.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "UCCL">
    <name>Unsafe Class Can Leak</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The class ‘class’ is unsafe, wrong usage can cause memory/resource leaks for ‘class::varname’. This can for instance be fixed by adding proper cleanup in the destructor.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UCE">
    <name>Useless Calls Empty</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Ineffective call of function ‘empty()’. Did you intend to call ‘clear()’ instead?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "UCF">
    <name>Use Closed File</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Used file that is not opened.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "UCR">
    <name>Useless Calls Remove</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The return value of std::remove() is ignored. This function returns an iterator to the end of the range containing those elements that should be kept. Elements past new end remain valid but with unspecified values. Use the erase method of the container to delete them.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "UCS">
    <name>Useless Calls Swap</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The ‘swap()’ function has no logical effect when given itself as parameter (str.swap(str)). As it is currently the code is inefficient. Is the object or the parameter wrong here?&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "UCSS">
    <name>Useless Calls Substr</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Ineffective call of function ‘substr’ because it returns a copy of the object. Use operator= instead.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "UES">
    <name>Unhandled Exception Specification</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Unhandled exception specification when calling function foo(). Either use a try/catch around the function call, or add a exception specification for funcname() also.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UIL">
    <name>Use Initialization List</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don’t explicitly write them to the initialization list. You could avoid assigning ‘variable’ a value by passing the value to the constructor in the initialization list.&lt;/p&gt;&#x0A;</description>
    <priority>MAJOR</priority>
  </rule>
  <rule key = "UISM">
    <name>Uninit Struct Member</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Uninitialized struct member: a.b&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "UIV">
    <name>Uninitvar</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Uninitialized variable: varname&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "UMV">
    <name>Uninit Member Var</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Member variable ‘classname::varname’ is not initialized in the constructor.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "UNFD">
    <name>Unnecessary Forward Declaration</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The variable ‘name’ forward declaration is unnecessary. Type variable is already declared earlier.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UP">
    <name>Unsigned Positive</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Unsigned variable ‘varname’ can’t be negative so it is unnecessary to test it.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UPF">
    <name>Unused Private Function</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Unused private function: ‘classname::funcname’&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UPMC">
    <name>Unprecise Math Call</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Expression ‘1 - erf(x)’ can be replaced by ‘erfc(x)’ to avoid loss of precision.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UQ">
    <name>Unnecessary Qualification</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The extra qualification ‘type’ is unnecessary and is considered an error by many compilers.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "URC">
    <name>Unreachable Code</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Statements following return, break, continue, goto or throw will never be executed.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "URV">
    <name>Unread Variable</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Variable ‘varname’ is assigned a value that is never used.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UUAM">
    <name>Unused Allocated Memory</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Variable ‘varname’ is allocated memory that is never used.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UUF">
    <name>Unused Function</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The function ‘funcName’ is never used.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UUSM">
    <name>Unused Struct Member</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;struct or union member ‘structname::variable’ is never used.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UUSO">
    <name>Unused Scoped Object</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Instance of ‘varname’ object is destroyed immediately.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "UUV">
    <name>Unused Variable</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Unused variable: varname&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "UiS">
    <name>Uninitstring</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Dangerous usage of ‘varname’ (strncpy doesn’t always null-terminate it).&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "VAEM">
    <name>Va_end Missing</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;va_list ‘vl’ was opened but not closed by va_end().&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "VALUBS">
    <name>Va_list Used Before Started</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;va_list ‘vl’ used before va_start() was called.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "VASRP">
    <name>Va_start Reference Passed</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Using reference ‘arg1’ as parameter for va_start() results in undefined behaviour.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "VASSC">
    <name>Va_start Subsequent Calls</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;va_start() or va_copy() called subsequently on ‘vl’ without va_end() inbetween.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "VASWP">
    <name>Va_start Wrong Parameter</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;‘arg1’ given to va_start() is not last named argument of the function. Did you intend to pass ‘arg2’?&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "VD">
    <name>Virtual Destructor</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Class ‘Base’ which is inherited by class ‘Derived’ does not have a virtual destructor. If you destroy instances of the derived class by deleting a pointer that points to the base class, only the destructor of the base class is executed. Thus, dynamic memory that is managed by the derived class could leak. This can be avoided by adding a virtual destructor to the base class.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "VFNUB">
    <name>Var Func Null UB</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\012The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.\012The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.\012In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.\012To reproduce you might be able to use this little code example on 64bit platforms. If the output includes &quot;ERROR&quot;, the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the &quot;ERROR&quot; output go away.\012#include &lt;stdarg.h&gt;\012#include &lt;stdio.h&gt;\012\012void f(char *s, ...) {\012    va_list ap;\012    va_start(ap,s);\012    for (;;) {\012        char *p = va_arg(ap,char*);\012        printf(&quot;%018p, %s\n&quot;, p, (long)p &amp; 255 ? p : &quot;&quot;);\012        if(!p) break;\012    }\012    va_end(ap);\012}\012\012void g() {\012    char *s2 = &quot;x&quot;;\012    char *s3 = &quot;ERROR&quot;;\012\012    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64\012    f(&quot;first&quot;, s2, s2, s2, s2, s2, 0, s3, (char*)0);\012}\012\012void h() {\012    int i;\012    volatile unsigned char a[1000];\012    for (i = 0; i&lt;sizeof(a); i++)\012        a[i] = -1;\012}\012\012int main() {\012    h();\012    g();\012    return 0;\012}</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "VHE">
    <name>Variable Hiding Enum</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;variable ‘name’ hides enumerator with same name&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "VHT">
    <name>Variable Hiding Typedef</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The variable ‘name’ hides a typedef with the same name.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "VS">
    <name>Variable Scope</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The scope of the variable ‘varname’ can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops.&lt;/p&gt;&#x0A;&lt;p&gt;Here is an example where cppcheck will write that the scope for ‘i’ can be reduced:&lt;/p&gt;&#x0A;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; f(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; x)&#x0A;{&#x0A;  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&#x0A;  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (x) {&#x0A;    &lt;span class=&quot;co&quot;&gt;// it&apos;s safe to move &apos;int i = 0;&apos; here&lt;/span&gt;&#x0A;    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; n &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; ++n) {&#x0A;      &lt;span class=&quot;co&quot;&gt;// it is possible but not safe to move &apos;int i = 0;&apos; here&lt;/span&gt;&#x0A;      do_something(&amp;amp;i);&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;&lt;p&gt;When you see this message it is always safe to reduce the variable scope 1 level.&lt;/p&gt;&#x0A;</description>
    <priority>MINOR</priority>
  </rule>
  <rule key = "WMC">
    <name>Wrong Math Call</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Passing value ‘#’ to #() leads to implementation-defined result.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "WOBS">
    <name>Write Outside Buffer Size</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The number of bytes to write (3 bytes) are bigger than the source buffer (2 bytes). Please check the second and the third parameter of the function ‘write’.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "WPPS">
    <name>Wrong Pipe Parameter Size</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;The pipe()/pipe2() system command takes an argument, which is an array of exactly two integers. The variable ‘varname’ is an array of size dimension, which does not match.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "WPSAN">
    <name>Wrong Printf Scanf Arg Num</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;printf format string requires 3 parameters but only 2 are given.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "WPSPPE">
    <name>Wrong Printf Scanf Parameter Position Error</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;printf: referencing parameter 2 while 1 arguments given&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
  <rule key = "WROF">
    <name>Write Read Only File</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Write operation on a file that was opened only for reading.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "ZD">
    <name>Zerodiv</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Division by zero.&lt;/p&gt;&#x0A;</description>
    <priority>BLOCKER</priority>
  </rule>
  <rule key = "ZDC">
    <name>Zerodivcond</name>
    <description>&lt;h3&gt;Cppcheck&lt;/h3&gt;&lt;p&gt;Either the condition ’’ is useless or there is division by zero at line 0.&lt;/p&gt;&#x0A;</description>
    <priority>CRITICAL</priority>
  </rule>
</rulset>
